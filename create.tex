\section{Creating a Matahari Agent}

The best starting point to create a new Matahari agent is to fork the \href{https://github.com/matahari/matahari-agent-example}{example agent repository} on GitHub. The changes needed to customise the agent for your own purposes are documented in the repository, and this will be kept up to date with any changes in Matahari.
You can also refer to the \href{https://github.com/matahari/libvirt-qmf}{\texttt{libvirt-qmf}} code.

Matahari is built with \href{http://www.cmake.org/}{CMake} and we recommend that developers of external agents follow suit. The example agent contains a complete CMake configuration that can be customised with your own schema package name and source file list.

\subsection{Schema}

The first requirement for a new agent is a QMF schema. \href{https://cwiki.apache.org/qpid/qpid-management-framework.html#QpidManagementFramework-Schema}{The schema format is defined} by Apache Qpid, but the Matahari tools generate code for both QMF and D-Bus agents from the same schema.

\begin{figure}[h]
\begin{Verbatim}
<schema package="org.matahariproject.testagent">
    <class name="TestClass">
        <property name="hostname" type="sstr" access="RO" desc="Hostname" index="y" />

        <method name="sum" desc="Sum of two numbers">
            <arg name="x" dir="I" type="int32" />
            <arg name="y" dir="I" type="int32" />
            <arg name="result" dir="O" type="int32" />
        </method>
    </class>
</schema>
\end{Verbatim}
\caption{The example agent schema.}
\label{fig:schema}
\end{figure}

A class may comprise properties, statistics and methods.\footnote{Statistics are data that are expected to change rapidly.} As well as the usual numerical and string types, properties may include references to other objects.
Methods may have multiple output arguments, and upon failure may throw an Exception that is either a simple string\footnote{The Matahari headers provide a standard list of strings for common errors.} or an arbitrary object with its own schema.

Although the current agents in the Matahari tree all contain only a single object, it is possible both to define multiple classes and to instantiate multiple objects of each class.\footnote{\texttt{libvirt-qmf} provides an example.}

\subsection{Implementation}

Matahari agents are written in C++.
Operations such as processing command-line options, connecting to the broker and setting up the main event loop are handled by the \texttt{MatahariAgent} class, and are consistent across all Matahari agents.

You can add custom CLI options specific to your agent by calling the function \texttt{mh\_add\_option()} from \texttt{main()} prior to initialising your \texttt{MatahariAgent} instance.

The agent's main event loop is implemented using \texttt{glib}. You can add events such as timers and socket handlers required to interface with your library using \href{http://developer.gnome.org/glib/2.29/glib-The-Main-Event-Loop.html}{functions such as \texttt{g\_timeout\_add()}}.

Matahari also provides an API for logging.

\begin{marginfigure}
\fvset{fontsize=\scriptsize}
\begin{Verbatim}
int
TestAgent::setup(qmf::AgentSession session)
{
    _package.configure(session);
    qmf::Schema s = _package.data_testClass;
    _instance = qmf::Data(s);

    // Set values for the properties
    _instance.setProperty("hostname",
                          mh_hostname());

    // Publish the object
    getSession().addData(_instance);
    return 0;
}
\end{Verbatim}
\caption{A typical \texttt{setup()} method.}
\end{marginfigure}

\newthought{The code to} create the schema is autogenerated from the XML file. You need to register your particular schema with the QMF session by calling its configuration code from the \texttt{setup()} method of your \texttt{MatahariAgent} subclass.
You can then instantiate a \texttt{qmf::Data} object from the requisite schema for each object you want to manage. You should set default values for all of the properties immediately, before publishing the object by adding it to the QMF session.

You need to implement the glue code to initialise and update properties and resolve method call events to convert them into calls to your library.
At present you also need to implement method dispatch if you have more than one object to manage. The Matahari team hopes to eventually provide generic code to handle method dispatch.


